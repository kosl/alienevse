esphome:
  name: alienevse
  on_boot: 
    then:
      - output.turn_on: cp_ev_out_pwm
      - output.set_level:
          id: cp_ev_out_pwm
          level: "100%"
      - output.turn_off: cp_ch_out_b_out
      - output.turn_off: cp_ch_out_c_out

esp32:
  board: esp32-c3-devkitc-02
  framework:
    type: esp-idf

logger:
  level: DEBUG
  logs:
    adc.esp32: ERROR
    ct_clamp: INFO
    sensor: INFO

api:
  encryption:
    key: !secret alienevse_api_encryption_key

ota:
  - platform: esphome
    password: !secret alienevse_ota_password

wifi:
  networks:
    - ssid: !secret wifi_ssid
      password: !secret wifi_password
  output_power: 8.5dB
  power_save_mode: none  # Better reliability over power saving

  ap:
    ssid: "AlienEVSE Fallback Hotspot"
    password: !secret alienevse_ap_password

captive_portal:

external_components:
  - source: github://kosl/alienevse
    components: [ evse_cp_sampler ]

# - CP_CH_IN   GPIO1 (ADC)
# - CP_CH_OUT_B GPIO7 (digital out)
# - CP_CH_OUT_C GPIO6 (digital out)
# - CP_EV_IN   GPIO0 (ADC)
# - CP_EV_OUT  GPIO10 (PWM out)
# - CC_L1      GPIO2 (ADC)
# - CC_L2      GPIO3 (ADC)
# - CC_L3      GPIO4 (ADC)

# Enable built-in status LED on GPIO8
light:
  - platform: status_led
    id: esp_status_led
    pin:
      number: GPIO8
      inverted: true
      ignore_strapping_warning: true 

output:
  - platform: gpio
    id: cp_ch_out_b_out
    pin: GPIO7

  - platform: gpio
    id: cp_ch_out_c_out
    pin: GPIO6

  - platform: ledc
    id: cp_ev_out_pwm
    pin:
      number: GPIO10
      allow_other_uses: true
    frequency: 1000Hz # default

globals:
  - id: last_raw_adc_count
    type: int

  # 0=unknown, 1=A, 2=B, 3=C, 4=D
  - id: evse_state
    type: int
    initial_value: "1"

switch:
  - platform: template
    name: "Charging Enabled"
    id: charging_enabled
    optimistic: True
    restore_mode: RESTORE_DEFAULT_OFF
    on_state:
      then:
        - script.execute: evse_update_state_script

number:
  - platform: template
    name: "Charging Amps"
    id: charging_amps
    min_value: 6
    max_value: 16
    step: 1
    restore_value: True
    mode: slider
    optimistic: True
    on_value: 
      then:     
        - script.execute: evse_update_state_script

text_sensor:
  - platform: template
    id: charging_state
    name: "State"
    entity_category: diagnostic
    update_interval: never

# Control Pilot voltage sampling at ADC at GPIO0 occurs 20 Âµs after PWM (ledc at GPIO10) rising edge
# Heartbeat sampling at 500 Hz in DC mode (when PWM is disabled) 
evse_cp_sampler:
    id: cp_sampler
    pwm_interrupt_pin:
      number: GPIO10
      allow_other_uses: true
    sample_adc: cp_ev_in
    samples: 250
    on_raw_value:
      - lambda: |-
          id(last_raw_adc_count) = x;
          // ESP_LOGD("evse_cp_sampler", "Raw ADC count: %d", x);         
    on_state_change:
      - lambda: |-
          ESP_LOGD("evse_cp_sampler", "New state: %d", x);
          id(evse_state) = x;
      - script.execute: evse_update_state_script

script:
  - id: evse_update_state_script
    mode: queued  # or 'single' / 'restart' depending on your needs
    then:
      # Calculate target values based on state
      - lambda: |-
          const int state = id(evse_state);
          const bool enabled = id(charging_enabled).state;
          const float amps = id(charging_amps).state;
          float duty = amps/0.6;
          bool relay_b = false;
          bool relay_c = false;     

          switch(state) {
            case 1:
              id(charging_state).publish_state("A (no vehicle)");
              duty = 100.0; relay_b = relay_c = false;
              break;
            case 2:
              if (enabled) {
                id(charging_state).publish_state("B1 (charging enabled)");
              } else {
                id(charging_state).publish_state("B2 (charging disabled)");
                duty = 100.0;
              } 
              relay_b = true; relay_c = false;
              break;
            case 3:
                if (enabled) {
                  id(charging_state).publish_state("C1 (charging requested)");
                } else {
                  duty = 100.0;
                  id(charging_state).publish_state("C2 (charging disabled)");
                }
                relay_b = true; relay_c = enabled;
              break;
            default:
              ESP_LOGE("update_state_script", "State %d occured");
              return;
          }
          id(cp_ev_in_diag).publish_state(id(last_raw_adc_count));
          id(cp_ev_out_pwm).set_level(duty/100.0); id(pwm_duty).publish_state(duty); 
          id(cp_ch_out_b_out).set_state(relay_b); id(cp_ch_out_c_out).set_state(relay_c);
          ESP_LOGI("update_state_script", "State %d, charging %d, %.0f A, duty %.0f%%, B%d C%d", 
            state, enabled, amps, duty, relay_b, relay_c);

sensor:
  # =========== EVSE Control Pilot sensors ===========
  # - platform: adc
  #   id: cp_ch_in
  #   pin: GPIO1  
  #   attenuation: 12db
  #   raw: true
  #   update_interval: never
  #   internal: true

  # - platform: copy
  #   name: "Charger CP"
  #   id: cp_ch_in_diag
  #   source_id: cp_ch_in
  #   accuracy_decimals: 0
  #   entity_category: diagnostic
  #   filters:
  #     - throttle: 1s
    
  # =========== Vehicle Control Pilot sensors ===========
  - platform: adc
    id: cp_ev_in
    pin: GPIO0
    attenuation: 12db
    internal: True
    update_interval: never

  - platform: template
    name: "Vehicle CP ADC"
    id: cp_ev_in_diag
    unit_of_measurement: "counts" 
    entity_category: diagnostic 
    update_interval: never

  # =========== Current sensors ===========
  - platform: adc
    id: cc_l1
    pin: GPIO2
    attenuation: 6db
  - platform: ct_clamp
    sensor: cc_l1
    name: "L1 Current"
    update_interval: 1s
    filters:
      - median:
      - calibrate_linear:
          method: exact
          datapoints:
           - 0.0390 -> 0.0
           - 0.0630 -> 5.0
           - 0.1184 -> 11.0
           - 0.1665 -> 16.0
      - clamp:
          min_value: 0.0
  - platform: adc
    id: cc_l2
    pin: GPIO3
    attenuation: 6db
  - platform: ct_clamp
    sensor: cc_l2
    name: "L2 Current"
    update_interval: 1s
    filters:
      - median
      - calibrate_linear:
          method: exact
          datapoints:
           - 0.0380 -> 0.0
           - 0.0611 -> 5.0
           - 0.1167 -> 11.0
           - 0.1646 -> 16.0
      - clamp:
          min_value: 0.0
  - platform: adc
    id: cc_l3
    pin: GPIO4
    attenuation: 6db
  - platform: ct_clamp
    sensor: cc_l3
    name: "L3 Current"
    update_interval: 1s
    filters:
      - median
      - calibrate_linear:
          method: exact
          datapoints:
           - 0.0380 -> 0.0
           - 0.0607 -> 5.0
           - 0.1160 -> 11.0
           - 0.1644 -> 16.0
      - clamp:
          min_value: 0.0
  
  # =========== Diagnostic sensors ===========
  - platform: template
    name: "PWM Duty"
    id: pwm_duty
    unit_of_measurement: "%"
    accuracy_decimals: 1
    entity_category: diagnostic
    update_interval: never

  - platform: wifi_signal
    name: "WiFi Signal Strength"
    id: wifi_rssi
    update_interval: 1min  
    unit_of_measurement: "dBm"
    accuracy_decimals: 0
    device_class: signal_strength
    entity_category: diagnostic 

interval:
  - interval: 60s
    then:
      - lambda: |-
          id(cp_ev_in_diag).publish_state(id(last_raw_adc_count));

button:
  - platform: restart
    name: Reboot
    entity_category: diagnostic